#include "Parser.h"
#include "VM.h"
#include "Util.h"
#include "Cache.h"

using namespace std;

Parser::Parser() {}

Parser::~Parser() {
  if (operation_factory != nullptr) delete operation_factory;
}

vector<Token> Parser::StringsToParams(Cache *cache, vector<string> const &str_toks) {
  vector<Token> tokens;
  for (auto it = str_toks.begin(); it != str_toks.end(); ++it) {
    // skip first token (operation name)
    if (it == str_toks.begin()) continue;
    string str = *it;
    // is a variable
    if (str_is_variable(str)) {
      string varname = str.substr(1);
      Variable *v;
      if (cache->HasVariable(varname)) {
        v = cache->GetVariable(varname);
      } else {
        v = new Variable();
      }
      Token t = Token(v);
      tokens.push_back(t);
    }
  }
  return tokens;
}

Operation *Parser::ParseOp(Cache *cache, string const &line) {
  vector<string> str_toks = split_line(line);
  if (str_toks.empty()) {
    return nullptr;
  }

  vector<Token> params = StringsToParams(cache, str_toks);
  std::string op_name = str_toks.front();

  if (operation_factory->GetOperation(op_name) == nullptr) {
    cerr << "invalid operation: " << str_toks.front() << endl;
    return nullptr;
  }

  auto operation = (operation_factory->GetOperation(str_toks.front()))->Clone();
  operation->SetParams(params);

  if (!operation->HasValidParams()) {
    cerr << "invalid parameter types for " << str_toks.front() << endl;
    return nullptr;
  }
  cout << "operation found " << str_toks.front() << endl;
  cache->operations.push_back(operation);

  return nullptr;
}
